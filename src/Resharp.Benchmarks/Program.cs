using System.Text;
using BenchmarkDotNet.Running;
using Resharp.Benchmarks;

if (args is ["--generate"])
{
    GenerateSourceGenRegexes();
    return;
}

if (args is ["--profile", var profileName])
{
    var bench = new RedditBench();
    var method = typeof(RedditBench).GetMethod(profileName)
        ?? throw new Exception($"no method '{profileName}' on RedditBench");
    for (int i = 0; i < 10; i++) method.Invoke(bench, null);
    for (int i = 0; i < 5000; i++) method.Invoke(bench, null);
    return;
}

if (args is ["--readme"])
{
#if SOURCE_GEN
    RebarData.NameSet = SourceGenRegexes.Lookup.Keys.ToHashSet();
#endif
    BenchmarkRunner.Run<RebarBench>();
}
else if (args.Length == 0)
{
    RebarData.NameFilter = ShowMenu();
    BenchmarkRunner.Run<RebarBench>();
}
else
{
    BenchmarkSwitcher
        .FromAssembly(typeof(RebarBench).Assembly)
        .Run(args);
}

static string? ShowMenu()
{
    var benches = RebarData.AllBenches.Value;
    var groups = benches
        .Select(b => b.Group)
        .Distinct()
        .Order()
        .ToArray();
    var topLevels = groups
        .Select(g => g.Split('/')[0])
        .Distinct()
        .ToArray();

    var choices = new List<(string label, string? filter)>
    {
        ($"all ({benches.Length} benchmarks)", null)
    };
    foreach (var tl in topLevels)
    {
        int n = benches.Count(b => b.Group.StartsWith(tl + "/"));
        choices.Add(($"{tl} ({n})", tl + "/"));
    }
    foreach (var g in groups)
    {
        int n = benches.Count(b => b.Group == g);
        choices.Add(($"{g} ({n})", g + "/"));
    }

    Console.WriteLine();
    Console.WriteLine("select benchmarks:");
    for (int i = 0; i < choices.Count; i++)
        Console.WriteLine($"  [{i}] {choices[i].label}");
    Console.WriteLine();
    Console.Write("> ");

    var input = Console.ReadLine()?.Trim() ?? "";
    if (int.TryParse(input, out int idx) && idx >= 0 && idx < choices.Count)
        return choices[idx].filter;
    return input;
}

static void GenerateSourceGenRegexes()
{
    var selected = RebarData.AllBenches.Value
        .Where(b =>
            $"{b.Group}/{b.Name}" is "curated/03-date/ascii" or "curated/12-dictionary/single"
            || b.Group == "resharp/02-monster")
        .ToArray();

    var sb = new StringBuilder();
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// run: dotnet run -- --generate");
    sb.AppendLine("using System.Text.RegularExpressions;");
    sb.AppendLine();
    sb.AppendLine("namespace Resharp.Benchmarks;");
    sb.AppendLine();
    sb.AppendLine("public static partial class SourceGenRegexes");
    sb.AppendLine("{");

    for (int i = 0; i < selected.Length; i++)
    {
        var b = selected[i];
        var escaped = b.Pattern.Replace("\"", "\"\"");
        var opts = b.CaseInsensitive ? "RegexOptions.IgnoreCase" : "RegexOptions.None";
        sb.AppendLine($"    [GeneratedRegex(@\"{escaped}\", {opts})]");
        sb.AppendLine($"    private static partial System.Text.RegularExpressions.Regex Gen_{i}();");
        sb.AppendLine();
    }

    sb.AppendLine("    public static readonly Dictionary<string, System.Text.RegularExpressions.Regex> Lookup = new()");
    sb.AppendLine("    {");
    for (int i = 0; i < selected.Length; i++)
    {
        var key = $"{selected[i].Group}/{selected[i].Name}";
        sb.AppendLine($"        [\"{key}\"] = Gen_{i}(),");
    }
    sb.AppendLine("    };");
    sb.AppendLine("}");

    // find project directory
    var dir = AppContext.BaseDirectory;
    while (dir is not null && !File.Exists(Path.Combine(dir, "Resharp.Benchmarks.csproj")))
        dir = Path.GetDirectoryName(dir);

    if (dir is null)
    {
        // fallback: walk up from cwd
        dir = Directory.GetCurrentDirectory();
        while (dir is not null && !File.Exists(Path.Combine(dir, "Resharp.Benchmarks.csproj")))
            dir = Path.GetDirectoryName(dir);
    }

    var outPath = Path.Combine(dir ?? ".", "SourceGenRegexes.g.cs");
    File.WriteAllText(outPath, sb.ToString());
    Console.WriteLine($"generated {selected.Length} source-generated regexes -> {outPath}");
}
